<!DOCTYPE html ><html lang="en-US"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="shortcut icon" href="../icons/favicon.ico" /><link rel="stylesheet" href="../css/bulma.css" /><link rel="stylesheet" href="../css/font-awesome.min.css" /><link rel="stylesheet" href="../css/presentationStyle.css" /><link rel="stylesheet" href="../css/vs.min.css" /><script src="../scripts/jquery-3.5.1.min.js"></script><script src="../scripts/clipboard.min.js"></script><script src="../scripts/highlight.min.js"></script><script src="../scripts/presentationStyle.js"></script><title>File transfer</title><meta name="Title" content="File transfer" /><meta name="Help.Id" content="fcfdf116-6555-48ac-a562-70cfc4e1e033" /><meta name="Help.ContentType" content="Concepts" /><meta name="guid" content="fcfdf116-6555-48ac-a562-70cfc4e1e033" /><meta name="Description" content="In a movie/series/commercial context, a day on set may cost tens of thousands of dollars and can produce terabytes of data. (IOW, the data is extremely valuable." /><meta name="tocFile" content="../toc/IDA.xml" /></head><body><div class="fixedLayout"><div id="Header" class="fixedHeader"><div class="pageHeader level mb-0 py-2 px-4"><div id="TitleContainer" class="level-left"><div class="level-item"><img src="../icons/Help.png" /></div><div id="DocumentationTitle" class="level-item">Quine libraries user's guide</div></div><div id="LangFilterSearchContainer" class="level-right"><div class="level-item"><div class="dropdown is-hoverable"><div class="dropdown-trigger"><button class="button" aria-haspopup="true" aria-controls="dropdown-menu"><span id="CurrentLanguage"></span><span class="icon is-small"><i class="fa fa-angle-down" aria-hidden="true"></i></span></button></div><div class="dropdown-menu" role="menu"><div id="LanguageSelections" class="dropdown-content"><a class="dropdown-item languageFilterItem" data-languageId="cs">C#</a></div></div></div></div><div class="level-item"><form id="SearchForm" action="#" onsubmit="TransferToSearchPage(); return false;"><div class="field"><div class="control has-icons-left"><input id="SearchTerms" class="input" type="text" maxlength="200" placeholder="Search" /><span class="icon is-small is-left"><i class="fa fa-search"></i></span><button id="SearchButton" type="submit" class="is-hidden"></button></div></div></form></div></div></div></div><div class="fixedContent"><nav class="breadcrumb my-1 px-2 border-bottom" role="navigation"><ul id="TopicBreadcrumbs" /></nav><div id="ContentContainer" class="columns pl-5 pr-5 fixedContent"><div id="ShowHideTOCColumn" class="column is-hidden-tablet"><a id="ShowHideTOC">Show/Hide TOC</a></div><div id="TOCColumn" class="column is-hidden-mobile"><nav class="toc"><ul id="TableOfContents" class="toc-menu" /></nav></div><div id="Resizer" class="is-hidden"></div><div id="TopicContent" class="column content is-7"><h1>File transfer</h1><div><p>
        In a movie/series/commercial context, a day on set may cost tens of thousands of dollars and can produce
        terabytes of data. (IOW, the data is extremely valuable.)  The data must be offloaded from camera's magazine to external
        disks <em>reliably</em> and <em>fast</em> because magazines are reused quickly.  ("Magazine drives"
        must support recording of RAW high-resolution data in real-time. Because of this,  their cost is way higher than
        that of an average SSD drive , so there are only a few on the set, like two per camera).  The data is also insured, and the insurance company
        requires that there be at least two copies of the data, with the file hash being stored in some kind of a side-car catalog.
        In "manual workflow", MHL is used for this purpose, but we stored all metadata in the asset database.
      </p><p><strong>Quine.FileTransfer</strong> helps with a <em>superficially</em> simple problem: copying a file from source to one or more destinations.
        ("Source" and "destination" are abstract terms for the library: they may be a local disk, SMB mount or even BLOB storage in the cloud.)
        As the subsequent sections will explain, the problem is far from superficial when <em>speed and data integrity</em>
        are key features.  An earlier version of this library was the work-horse of QuineIngest and was used to copy many terabytes of data
        in real productions.  This version of the library is released with a cleaned-up API, more extensive test
        suite and a quick-start application.
      </p><p>
        See <a href="90fca4d6-615c-4b1d-b77b-0ff1f7baae4b.htm">Glossary</a> for commonly used terms.
      </p></div><h2 class="quickLinkHeader"><span class="icon toggleSection" tabindex="0"><i class="fa fa-angle-down"></i></span>Features</h2><div id="IDBABSection"><p>
          A file is copied to <em>multiple</em> destinations <em>in at most two passes</em>.
        </p><p>
          With proper configuration, it is possible to read/write data at nearly maximum throughput.
          Obviously, the total transfer time is limited by the slowest source / destination.
        </p><p>
          The integrity of the transfer can be optionally verified after copying by a 2nd hashing pass.  Each worker performs hashing
          in parallel with other workers, and the hashing algorithm can be chosen by the user.
        </p><p>
          It allows opening of a file without OS buffering to ensure that hashing verifies the
          <em>content actually present on storage</em> instead of its <em>in-memory copy</em>.
        </p><p>
          Allows cancellation of transfers.
        </p><p>
          Errors occuring during copying to one or more destination must not affect copying to other destinations.
        </p><p>
          Errors are reported reliably.  If an error occurred either at source or destination(s), it will be reported
          through the worker's exception property.
        </p><p>
          Extensibility: Out-of-the box, the library supports only OS files as source and destination.  However,
          it is possible to support other types of sources and destinations (e.g., FTP, Azure BLOBs or even DropBox)
          without meddling with the core logic.  By applying <em>decorator pattern</em>, it is possible to
          add features such as retry, timeouts and progress reporting.  This allows for clean separation between
          concerns and layered approach to system development.
        </p><p>
          Support for sources and destinations that can read/write multiple file blocks in parallel.
        </p><p>
          The library comes with a stress-test program.
        </p><article class="message is-info"><div class="message-header"><p><span class="icon"><i class="fa fa-info-circle"></i></span>  Note</p></div><div class="message-body"><p>
            The library is delivered with a number of low-overhead <span class="code">Trace.Assert</span> statements that ensure basic invariants
            which, if violated, would in the worst case lead to silent data corruption.  It is therefore not recommended to recompile the library
            without the <span class="code">TRACE</span> macro defined.
          </p><p>
            The assert behavior depends on the trace listeners collection.  The collection should be configured such that the program is
            stopped on assertion failure (which is the case by default).
          </p></div></article></div><h2 class="quickLinkHeader"><span class="icon toggleSection" tabindex="0"><i class="fa fa-angle-down"></i></span>Concepts</h2><div id="IDCABSection"><p>
          This library is used to copy a single <em>file</em> from an abstract "source" to one or more abstract "destinations".
          Sources and destinations are "abstract" in the sense that their backing storage can be OS files, FTP servers, Azure BLOBs, etc.
        </p><p>
          A file is an ordered sequence of bytes partitioned into equally-sized <em>blocks</em>.
          The file's size will almost never be a multiple of the block size: the example diagram shows a file consisting of 6 blocks:
          5 whole blocks (numbered 0-4) and one partial block (numbered 5; the striped portion is unused buffer space).
        </p><p>
          The block size is determined upon the
          creation of <a href="0126e38a-fc2d-9693-2587-be2d601db2d6.htm">TransferDriver</a> and
          cannot be changed.  It is available through <a href="b954b9bd-f48d-1a85-0723-b5c40950b016.htm">BlockSize</a>
          property.
        </p><figure class="mediaNear"><figcaption>Producer/consumer view of a file</figcaption><img alt="File Structure" src="../media/FileStructure.png" /></figure><p>
          The copying process involves the following (active) participants
        </p><dl><dt>
            Driver
          </dt><dd><p>
              Users of the library use an instance of <a href="0126e38a-fc2d-9693-2587-be2d601db2d6.htm">TransferDriver</a>
              to start or cancel a file transfer and control hash verification.  Internally, it serves as a "blackboard" for coordination between
              the producer and the consumers.  Among other things, it holds a preallocated pool of buffers (equally-sized blocks of native memory)
              which are freed when the driver instance is disposed.
            </p></dd><dt>
            Buffer (block)
          </dt><dd><p>
              A block of memory managed by the driver and used to transfer file data from the producer to the consumers.  An individual
              buffer is represented by <a href="9ec6bf64-9be3-721b-dd78-0720ec012b95.htm">ITransferBuffer</a>
              instance. (Other properties, such as use count, are present as well, but are <span class="code">internal</span> to the
              assembly.)  The buffer's position in the file is determined by <a href="db6bab8c-9382-8db0-4a2c-68a85f4f120f.htm">Sequence</a>
              property.
            </p></dd><dt>
            Producer
          </dt><dd><p>
              A class implementing <a href="898a4f40-12c7-e5b1-57e4-bb329c3e9659.htm">ITransferProducer</a>
              that fills a memory block with data obtained from a source. (Example: reading from an OS file.)
            </p></dd><dt>
            Consumer
          </dt><dd><p>
              A class implementing <a href="f707bb22-3c9c-ae7e-d1de-8fbeeab7e96d.htm">ITransferConsumer</a>
              that processes data handed over by the producer.  (Example: writing to an OS file, or adding data to incremental hash computation.)
            </p></dd></dl><figure class="mediaNear"><figcaption>Data flow in a file transfer</figcaption><img alt="File Transfer Flow" src="../media/FileTransferFlow.png" /></figure><p>
          For each transfer, the producer and consumers execute the following algorithm:
        </p><ol><li><p>
              Initialize (e.g, open an OS file).
            </p></li><li><p>
              Loop until EOF or exception.
            </p><ul><li><p>
                  The producer obtains a buffer from the pool and fills it with data.
                  If there is no more data at the source, it signals EOF to the consumers.
                  Otherwise, it broadcasts the buffer to the consumers and keeps reading the data.
                </p></li><li><p>
                  The consumer waits for a buffer from the producer and process it (e.g., hash it or write to backing storage).
                  After processing, it returns the buffer to the buffer pool.
                </p></li></ul><p>
              Reference counting ensures that the producer cannot reuse a buffer before it has been returned by all consumers.
            </p></li><li><p>
              Compute verification hash (if requested) and finalize (e.g., close an OS file).
            </p></li></ol><p>
          Depending on how the concrete implementation defines <a href="66874b03-741d-93bd-cbd8-7d61db48eb1b.htm">MaxConcurrency</a>,
          the loop in step 2 might spawn many parallel tasks.  Errors are handled by the framework: if the producer or any consumer has failed,
          its <a href="ea5ccab1-5713-9437-1d97-ddc640eac842.htm">Exception</a> property will
          reflect the failure.  If all consumers fail, the driver cancels the rest of the transfer.
        </p></div><h2 class="quickLinkHeader"><span class="icon toggleSection" tabindex="0"><i class="fa fa-angle-down"></i></span>Extending the library</h2><div id="IDDABSection"><p>
          Out of the box, the library supports only unbuffered native files on Windows and OSX as producers and consumers; these are derived from
          <a href="0a2c74b3-4574-9e50-4ba1-634496290db9.htm">UnbufferedFile</a>.
          As the name suggests, it turns off OS buffering to make sure that the data being read or written actually comes directly from
          the backing media instead of from the OS cache.  (Turning off buffering was necessary because QI handled valuable data.  In situations
          where a magazine would completely fit into the machine's cache, the point of hash verification would be completely defeated
          as it would read the data back from the cache instead of from media.  Unbuffered IO -- when
          done right -- is also more performant because it avoids double copying of data, first to the OS cache in kernel-space, followed
          by copying from cache to user-space buffer.)
        </p><article class="message is-info"><div class="message-header"><p><span class="icon"><i class="fa fa-info-circle"></i></span>  Tip</p></div><div class="message-body"><p>
            Use existing implementations as guidelines.
          </p></div></article><p>
          To add new behavior to existing implementataion of producer or consumer, use the <em>decorator pattern</em> with composition.
          If the interface methods are  implemented virtually, it is also possible to use subclassing with base invocation: this
          approach is not composable, but it entails less boiler-plate when a reusable decorator is not needed.
        </p><p>
          To support other hash algorithms, create a class implementing <a href="6880c21b-d649-ae87-5e1f-a3c64c939129.htm">ITransferHasher</a>.
        </p><p>
          To add support for storage mechanisms other than local files, create classes that respectively implement
          <a href="898a4f40-12c7-e5b1-57e4-bb329c3e9659.htm">ITransferProducer</a>
          or <a href="f707bb22-3c9c-ae7e-d1de-8fbeeab7e96d.htm">ITransferConsumer</a>.
        </p><p>
          Design the implementation so that the same instance is <em>reusable</em> for many transfers.
        </p><p>
          DO check for cancellation manually if the I/O methods do not natively support cancellation. The cancellation token is available
          through <a href="7da8b9f9-e73f-df3e-2276-91e349881307.htm">CancellationToken</a>
          property on <a href="52eb0c1f-2d8d-6eeb-349f-fa0fe78e0953.htm">State</a>.
        </p><p>
          If the implementation has <a href="66874b03-741d-93bd-cbd8-7d61db48eb1b.htm">MaxConcurrency</a>
          equal to 1, it is guaranteed that sequence numbers referring to file blocks to be processed will be sequential.  This makes
          it possible to support non-seekable sources/destinations (e.g., tape drives).
        </p><p>
          Use exceptions to signal errors.  If you study existing producers and consumers, you will see that they do not catch
          exceptions: <span class="code">try/finally</span> blocks are used for resource management.  The framework will stop
          invoking <a href="b88bbacf-977d-3ba9-4763-b6090e4217d6.htm">FillAsync</a>
          or <a href="e11b1461-33bd-829e-34df-575566749e8e.htm">DrainAsync</a>
          after an exception has been thrown, regardless of concurrency level.
        </p><p><a href="bac4783e-93eb-630b-4595-c259fb5465e3.htm">InitializeAsync</a>
          and <a href="68f0675f-001f-89d9-bd0d-e27c3214416b.htm">FinalizeAsync</a>
          manage lifecycle of an individual transfer and they are therefore <em>always</em> invoked.  Use the initialize method to acquire "resources"
          and finalize method to release them.  If errors occurred during execution, the hasher argument to <span class="code">FinalizeAsync</span>
          is guaranteed be <span class="code">null</span>.
        </p><article class="message is-warning"><div class="message-header"><p><span class="icon"><i class="fa fa-warning"></i></span>  Important</p></div><div class="message-body"><p>
            For correct operation, it is <em>crucial</em> that <span class="code">FillAsync</span> and <span class="code">DrainAsync</span>
            fill/drain the complete buffer <a href="56544405-c17d-96ca-3404-6b2a14f45133.htm">Memory</a>.
            The ONLY case where it's allowed that <a href="69a3a91a-0917-f294-dcee-9a05b89cf5de.htm">Data</a>
            is shorter than <a href="56544405-c17d-96ca-3404-6b2a14f45133.htm">Memory</a> is
            the last block of the file as shown in <span class="noLink">this figure</span>.
          </p><p><span class="code">FinalizeAsync</span> is invoked even if <span class="code">InitializeAsync</span> threw.  Ensure that
            this case is handled correctly.
          </p></div></article><p>
          The rationale behind the "weird" signature and sematics of
          <a href="68f0675f-001f-89d9-bd0d-e27c3214416b.htm">FinalizeAsync</a>
          is that it must be possible to compute the verification hash before releasing the resources associated with the file being read/written.
        </p><blockquote>
          War story: an older design with different signature of <span class="code">FinalizeAsync</span> closed the file after writing and reopened
          it for hashing.  In production use, this caused hash verification to spuriously fail with "file in use" exception.  The investigation
          revealed that the small time-window between closing and reopening the file was enough for an anti-virus program to kick in and open
          the file in "no share" mode.
        </blockquote></div><h2 class="quickLinkHeader"><span class="icon toggleSection" tabindex="0"><i class="fa fa-angle-down"></i></span>See Also</h2><div id="seeAlsoSection"><h4>Other Resources</h4><div><a href="9ebe03ad-060c-4ffd-9a31-965f01f40ca0.htm">Getting started with FileTransfer</a></div></div></div><div id="InThisArticleColumn" class="column is-hidden-mobile"><nav class="menu sticky is-hidden"><p class="menu-label"><strong>In This Article</strong></p><ul id="InThisArticleMenu" class="menu-list"><li><a class="quickLink">Features</a></li><li><a class="quickLink">Concepts</a></li><li><a class="quickLink">Extending the library</a></li><li><a class="quickLink">See Also</a></li></ul></nav></div></div></div><footer id="PageFooter" class="footer border-top py-3 fixedFooter"><div class="columns"><div id="FooterContent" class="column"><p><a href="(c) 2024-2025 Stian Z. Vrba" target="_blank" rel="noopener noreferrer">(c) 2024-2025 Stian Z. Vrba</a></p> 
				</div></div></footer></div><script>$(function(){
SetDefaultLanguage("cs");
LoadTocFile(null, null);
InitializeQuickLinks();

$(".toggleSection" ).click(function () {
    SectionExpandCollapse(this);
});

$(".toggleSection").keypress(function () {
    SectionExpandCollapseCheckKey(this, event)
});
});</script></body></html>